Moar is a pager.  It's designed to be easy to use and just do the
right thing without any configuration.

TODO (in some order):

* Scroll down if we have no search hit on the current screen

* Somehow indicate if we have no search hits at all

* Write "/ to search" somewhere in the status field

* Do a regexp search if the search term is a valid regexp, otherwise
  just use it as a substring.

* Highlight search hits using reverse video

* Make the search case sensitive only if it contains any capital
  letters.  This goes for both regexps and non-regexps.

* Make sure we get the line length right even with unicode characters
  present in the lines.  Verify by looking at where the truncation
  markers end up.

* Find next using n

* Find previous using N

* Scroll down one line on RETURN

* Enable sideways scrolling using arrow keys.

* Handle search hits to the right of the right screen edge

* Interactive search using ^s and ^r like in Emacs

* Highlight all matches while searching

* Enable displaying ANSI-colored input

* Enable filtered input, start with zcat as a filter

* Enable source code highlighting by pre-filtering using some
  highlighter.

* Enable exiting using ^c (doesn't restore screen).

* Just pass stuff through if stdout is not a terminal.

* Enable up / down using whatever less uses.

* Enable home / end using home / end keys.

* Just do nothing if our input is of zero length

* Enable up / down using the mouse wheel.

* Enable 'h' or '?' for help

* Report command line errors, think about when to use $stdin for input
  vs what commands we accept

* Make sure we can properly render all lines of /etc/php.ini.default
  without the bottom-of-the-screen prompt moving around.

* Enable pass-through operation unless $stdout.isatty()

* Change out-of-file visualization to writing <END> after the end of
  the file and leaving the rest of the screen blank.

* Doing moar.rb on an arbitrary binary should put all
  line-continuation markers at the rightmost column.  This really
  means our truncation code must work even with things like tabs and
  various control characters.


DONE:
* Enable exiting using q (restores screen)

* Handle the terminal window getting resized.

* Print info line in inverse video

* Enable up / down using arrow keys.

* Prevent pressing down past the last line of the file.

* Enable out-of-file visualization with ~ like less.

* Enable up / down using page-up and page-down keys.

* Enable home / end using < and >.

* Enable file input.

* Enable continuous position display with everything we know (lines
  visible, percentages, like less).

* Enable stdin input.

* Truncate lines that are longer than the screen width

* Make sure we can print all the way into the rightmost column of the
  screen when truncating too long lines.  We should strip() lines
  before we print them and manually move the cursor to the next line
  after each.

* Handle all kinds of line endings.

* Handle files missing an ending newline.

* Handle hitting BACKSPACE in the search field

* Interactive search using /

* Typing backspace in the line editor when it's empty should make the
  line editor say "done".
